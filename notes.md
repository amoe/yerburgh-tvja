# Notes

The forum is linked here: https://forums.manning.com/forums/testing-vuejs-applications

## Ch1

"User journey" is defined to be a route through an application.  Open X, click
Y, type Z.

Runs over the usual disadvantages of end to end tests.  But says problem
with unit tests is that it makes it difficult to refactor code.  Not sure why.

Then talks about snapshot tests and mentions this cool fact:

> Instead of comparing screenshots, Jest snapshot tests can compare any
> serializable value in JavaScript. You can use them to compare the DOM output
> from Vue components.

Defines a testing pyramind of 60% unit, 30% snapshot, 10% e2e.

Ed outlines his process for a Vue component:

> 1. Decide the components I need
> 2. Write unit tests and source code for each component
> 3. Style the component
> 4. Add snapshot tests for a finished component
> 5. Test the code manually in the browser
> 6. Write an end-to-end test.

There are two main ways to describe DOM nodes: templates and render functions.
Templates are compiled into render functions using the compiler.  Most stuff
should be done using templates.  But getting from template -> render function is
a separate compile step that needs to be repeated in the test.

This book doesn't use TypeScript, so bear that in mind.  We may need to revise
the existing TypeScript setup to integrate with this testing setup.  Remember
that typescript SFCs use `<script lang="ts>`.

Take-away: an SFC compiles into a single object with a render function.

Here's the good shit: deciding what parts of a component to test.

> If you wrote tests for every property of a component, you would slow down
> development and create an inefficient test suite.  One method for deciding
> what parts of a component should be tested is to use the concept of a
> component contract. A component contract is the agreement between a component
> and the rest of the application.

The contract is defined in term of an input / output relation (eg a function).

> A common input for a component is a user action, like when a user clicks a
> button. The most common output is the DOM nodes generated by the render
> function.

He gives an example of output as 'external function call' -- this is essentially
spying / mocking?

Imagine a fictional situation with a component `AuthorizedStatus`.
We have a boolean prop on the component `authorized`.  So it's instantiated
as such, `<authorized-status :authorized="isAuthorized">`.

If the prop is true, it's going to render "you're authorized", otherwise it's
going to render "you're not authorized".  It's interesting because here props
essentially constitute the argument to the function.  This is the contract
of the component.  Note that this seems to be a form of SRP on the model basis.
The very interesting thing about this is that it isn't comparable to Java, where
you test the methods of a class.  Instead the render function is the part
that's being tested.

*Ch1 finished*

## Ch2

Vue conventional directory structure is outlined that uses vue-cli.
It includes `/public` , `src/components`, and `src/api`.  The API functions
are treated as a black box for our purposes, but they still could be useful
to demonstrate good API writing style.
`public/` is for assets that shouldn't be processed by webpack.

`npm run serve` is used for the dev server.

Find the example repo here:
https://github.com/eddyerburgh/vue-hackernews

Every chapter has its own branch.  It requires `vue-cli-service`, no idea what
this is.  THe dev server spawns on localhost:8080.  It automatically loads
'items' which is presaumably some API code.  Firebase is used for the API
for some reason that I can't understand.


## Errata from Dave

No proofreading comments: they have pro proofreaders
