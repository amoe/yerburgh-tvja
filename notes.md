# Notes

The forum is linked here: https://forums.manning.com/forums/testing-vuejs-applications

## Ch1

"User journey" is defined to be a route through an application.  Open X, click
Y, type Z.

Runs over the usual disadvantages of end to end tests.  But says problem
with unit tests is that it makes it difficult to refactor code.  Not sure why.

Then talks about snapshot tests and mentions this cool fact:

> Instead of comparing screenshots, Jest snapshot tests can compare any
> serializable value in JavaScript. You can use them to compare the DOM output
> from Vue components.

Defines a testing pyramind of 60% unit, 30% snapshot, 10% e2e.

Ed outlines his process for a Vue component:

> 1. Decide the components I need
> 2. Write unit tests and source code for each component
> 3. Style the component
> 4. Add snapshot tests for a finished component
> 5. Test the code manually in the browser
> 6. Write an end-to-end test.

There are two main ways to describe DOM nodes: templates and render functions.
Templates are compiled into render functions using the compiler.  Most stuff
should be done using templates.  But getting from template -> render function is
a separate compile step that needs to be repeated in the test.

This book doesn't use TypeScript, so bear that in mind.  We may need to revise
the existing TypeScript setup to integrate with this testing setup.  Remember
that typescript SFCs use `<script lang="ts>`.

Take-away: an SFC compiles into a single object with a render function.

Here's the good shit: deciding what parts of a component to test.

> If you wrote tests for every property of a component, you would slow down
> development and create an inefficient test suite.  One method for deciding
> what parts of a component should be tested is to use the concept of a
> component contract. A component contract is the agreement between a component
> and the rest of the application.

The contract is defined in term of an input / output relation (eg a function).

> A common input for a component is a user action, like when a user clicks a
> button. The most common output is the DOM nodes generated by the render
> function.

He gives an example of output as 'external function call' -- this is essentially
spying / mocking?

Imagine a fictional situation with a component `AuthorizedStatus`.
We have a boolean prop on the component `authorized`.  So it's instantiated
as such, `<authorized-status :authorized="isAuthorized">`.

If the prop is true, it's going to render "you're authorized", otherwise it's
going to render "you're not authorized".  It's interesting because here props
essentially constitute the argument to the function.  This is the contract
of the component.  Note that this seems to be a form of SRP on the model basis.
The very interesting thing about this is that it isn't comparable to Java, where
you test the methods of a class.  Instead the render function is the part
that's being tested.

*Ch1 finished*

## Ch2

Vue conventional directory structure is outlined that uses vue-cli.
It includes `/public` , `src/components`, and `src/api`.  The API functions
are treated as a black box for our purposes, but they still could be useful
to demonstrate good API writing style.  However it uses Firebase, so in my view
it's bad by definition.

`public/` is for assets that shouldn't be processed by webpack, unlike the
`static` that we use.

`npm run serve` is used for the dev server.
`npm t` is a shortcut for `npm run test`.
The `build` target runs webpack and constructs everything into a 'build'
directory that can be deployed to a server.


Find the example repo here:
https://github.com/eddyerburgh/vue-hackernews

Every chapter has its own branch.  It requires `vue-cli-service`, no idea what
this is.  THe dev server spawns on localhost:8080.  It automatically loads
'items' which is presumably some API code.  Firebase is used for the API
for some reason that I can't understand.

Introduces the concept of a sanity test: this is basically the 2+2==4 test
that I normally write.

We use Jest as the test runner.  We install jest and add the `test:unit` target
to package.json.

Now I remember how disgusting the default Jest configuration is, but I also
remember some severe pain happening the last time that I tried to change it,
so for now I'll just reluctantly go with it.

The `test` function has to return a Promise or undefined.  This is cool because
it indicates that Jest has strict error checking, perhaps.  We enter the nightmare
where different tools don't know about each others' scoping rules.  Luckily
eslint has a special setting for jest.

So we talk about how expectations work in Jest.  `expect` returns a magic object
that has a bunch of 'matcher' methods.

Eslint is auto-fixing my problems but it can definitely go away.  Add --no-fix
because vue-cli-service automatically wants to pass --fix parameter to eslint.

Discusses avoiding false positives with example of async testing.  Obviously
you want to wait in your test, you usually setTimeout to wait, but in this case
your function will exit and so your assertion will never be called.  The red
stage of TDD avoids false-positives.  Your test has to fail for the right reason.

**The red test should fail because the assertion evaluates to false**

`describe` defines a test suite.  It takes a string argument and a function.
The tip is to never nest 'describe', even though you can.  Just use longer
test names.  I'd definitely agree with this tip, favouring a single
descriptive test name even with redundancy.

And we also experience the failed configuration attached to not being able to
import Vue files.  It's funny to experience this ecosystem clusterfuck in
documented form.  People will look back on this and laugh, perhaps.  Apparently
Jest and Webpack are incompatible because Webpack is asynchronous.

We need to use a special 'transformer' to get Jest to work at all when importing
SFCs.  `babel-jest` and `vue-jest`.  They are manually configured in the jest
object inside package.json.  Having installed and configured these, we can
at least build.

The process of constructing a new instance inside a unit test looks as follows,
where `Item` is your component.   `Ctor` is just an arbitrary name.

    const Ctor = Vue.extend(Item);
    const vm = new Ctor();

To mount you call $mount explicitly (with no args).  Now you can access DOM
nodes in $el.  Jest has some magic and runs test inside "JSDOM".

There's an important conclusion here and that conclusion is that Jest is really
the only sensible way to write unit tests because of the necessity of components
to render using the DOM API.  The basic no-magic way to write tests looks as 
follows.

    const Ctor = Vue.extend(Item);
    const vm = new Ctor();
    vm.$mount();
    expect(vm.$el.textContent).toContain('item');

However vue-test-utils contains some type of magic to ease this.

That magic is the mount() function which returns a wrapper object.  The wrapper
contains other cool stuff that you can use.  For instance, wrapper.text()
is going to give you the textContent in a similar way.  So these are some
abbreviations for the regular DOM api.

There's also shallowMount which will only render one level deep and should
probably be the default (as it is later).

## Errata from Dave

No proofreading comments: they have pro proofreaders
